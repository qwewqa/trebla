package std

// A transformation matrix for 2d coordinates.
// The matrix in level data is 4x4, but since the Sonolus is 2d, z can be ignored.
struct Transform(
    _11, _12, _13,
    _21, _22, _23,
    _31, _32, _33,
)

operator func Transform.times(other: Transform) = Transform(
    this._11 * other._11 + this._12 * other._21 + this._13 * other._31, this._11 * other._12 + this._12 * other._22 + this._13 * other._32, this._11 * other._13 + this._12 * other._23 + this._13 * other._33,
    this._21 * other._11 + this._22 * other._21 + this._23 * other._31, this._21 * other._12 + this._22 * other._22 + this._23 * other._32, this._21 * other._13 + this._22 * other._23 + this._23 * other._33,
    this._31 * other._11 + this._32 * other._21 + this._33 * other._31, this._31 * other._12 + this._32 * other._22 + this._33 * other._32, this._31 * other._13 + this._32 * other._23 + this._33 * other._33,
)
infix func Transform.then(other: Transform) = other * this

// This is sufficient to set the value of the level transform, assuming only affine transforms have been applied,
// since the bottom row will always be [0, 0, 1] in that case.
func Transform.setAffine(value: Transform) {
    this._11 = value_11
    this._12 = value_12
    this._13 = value_13
    this._21 = value_21
    this._22 = value_22
    this._23 = value_23
}

let identityTransform = Transform(
    1, 0, 0,
    0, 1, 0,
    0, 0, 1,
)

func translationTransform(x: Number = 0, y: Number = 0) = Transform(
    1, 0, x,
    0, 1, y,
    0, 0, 1,
)

func scaleTransform(x: Number = 1, y: Number = 1) = Transform(
    x, 0, 0,
    0, y, 0,
    0, 0, 1,
)

func rotationTransform(theta: Number = 0) = Transform(
    cos(theta), -sin(theta), 0,
    sin(theta), cos(theta), 0,
    0, 0, 1,
)

func shearTransform(x: Number = 0, y: Number = 0) = Transform(
    1, x, 0,
    y, 1, 0,
    0, 0, 1,
)