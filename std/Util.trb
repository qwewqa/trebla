package std

func copy(value): Any {
    try {
        var ret = value
        ret
    } except {
        // fully immutable values cannot be used to initialize a var
        value
    }
}

func judge(
    src: Number, dst: Number,
    min1: Number, max1: Number,
    min2: Number, max2: Number,
    min3: Number, max3: Number,
) = Number(builtins.Judge(
    src, dst,
    min1, max1,
    min2, max2,
    min3, max3,
))

func judgeSimple(
    src: Number, dst: Number,
    max1: Number,
    max2: Number,
    max3: Number,
) = Number(builtins.JudgeSimple(src, dst, max1, max2, max3))

func run(block: Callable): Any = block()
func Any.ref(block: Callable) = block(this)
func Any.also(block: Callable): Any {
    block(this)
    this
}

operator func Type.deref() = Pointer[this]
operator func Script.deref() = EntityPointer[this]

func Any.localPointer() = pointerTo(this)
func Any.pointer(): Pointer {
    let pointer = this.localPointer()
    typeOf(pointer)(
        block = const when {
            pointer.block == ENTITY_DATA -> ENTITY_DATA_ARRAY + 32 * entityIndex
            pointer.block == ENTITY_SHARED_MEMORY -> ENTITY_SHARED_MEMORY_ARRAY + 32 * entityIndex
            else -> pointer.block
        },
        index = pointer.index,
    )
}

// Use of infix (non short-circuiting) "and" helps with readability of IR
// Optimizer could eventually clean things up otherwise
operator func Type.equals(other: Any) = (typeOf(other) === Type) and typeAccepts(this, other) and typeAccepts(other, this)
operator func Type.notEquals(other: Any) = !(this == other)
operator func Type.greaterOr(other: Any) = typeAccepts(this, other)
operator func Type.lessOr(other: Any) = typeAccepts(other, this)
operator func Type.greater(other: Any) = (this >= other) and (this != other)
operator func Type.less(other: Any) = (this <= other) and (this != other)

func Range.execute(op: Callable) = this(op)
infix func Number.until(other: Number) = Range(this, other)
infix func Number.through(other: Number) = const if (other > this) {
    Range(this, other + 1)
} else {
    Range(this, other - 1)
}

infix func Range.by(n: Number) = Range(this.start, this.stop, n)

infix func Enum.matches(variant) = typeOf(this) == variant.parent && this.ordinal == variant.ordinal
