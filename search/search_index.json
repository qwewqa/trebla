{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trebla A programming language and compiler for creating rhythm game engines on Sonolus . Quick Start Download the corresponding executable for your operating system from releases . Unstable builds are available as build artifacts . Add the executable to the PATH if desired. Check the documentation at https://trebla.qwewqa.xyz for more information. Building from Source Trebla was built and tested with JDK 14, but JDK 8 or higher should suffice. Clone via git. git clone Run via gradle. gradlew run --args=\"[arguments]\" See gradlew tasks for other options. Documentation Documentation is built using mkdocs and the material theme .","title":"Home"},{"location":"#trebla","text":"A programming language and compiler for creating rhythm game engines on Sonolus .","title":"Trebla"},{"location":"#quick-start","text":"Download the corresponding executable for your operating system from releases . Unstable builds are available as build artifacts . Add the executable to the PATH if desired. Check the documentation at https://trebla.qwewqa.xyz for more information.","title":"Quick Start"},{"location":"#building-from-source","text":"Trebla was built and tested with JDK 14, but JDK 8 or higher should suffice. Clone via git. git clone Run via gradle. gradlew run --args=\"[arguments]\" See gradlew tasks for other options.","title":"Building from Source"},{"location":"#documentation","text":"Documentation is built using mkdocs and the material theme .","title":"Documentation"},{"location":"about/project-background/","text":"Project Background Trebla is a programming language targeting the script format used by levels in Sonolus, a rhythm game (a game where the player generally completes actions according to the beat of background music) where all behavior in a level is governed by user defined scripts. For more information about Sonolus, check out the website or the wiki for more information. Sonolus Many design aspects of Trebla are best understood in the context of the execution model used by Sonolus. Nodes A level in Sonolus is simply a JSON file defining gameplay elements and their behaviors. The behavior of a level is defined in its script which is a single array of \"nodes\". A node can be either: (1) a builtin function which references other nodes by index as arguments, including special control flow functions (If, While, ...), mathematical functions (Add, Subtract, ...), memory related functions (Get, Set, ...), and gameplay related functions(Draw, Play, ...), or (2) a literal floating-point value. Gameplay elements (entities) can reference particular nodes as callbacks to be called at different times, such as every frame or in response to player input. Directly editing nodes by hand would be tedious, so scripting is generally done in another language which compiles down to nodes. The provided SIL language is one such language, providing a basic interface on top of nodes. Trebla aims to provide a higher level language and a more familiar programming experience than SIL. Memory Scripts can store or read data from a number of blocks , arrays of numbers defined for various purposes. Blocks can either have a fixed size or vary in size based on the number of entities defined in a level. Some blocks are specific to the entity calling a script while others are shared globally. Some languages for Sonolus such as the provided SIL language require users to manually specify and manage memory indexes. Trebla abstracts this away, automatically assigning memory to user defined variables. This includes both statically assigning memory locations (blocks indexes) for global or entity related variables, and potentially assigning multiple memory locations and reusing memory locations for temporary variables to minimize memory used (this essentially uses the same algorithms as register allocation where each memory location can be thought of as a register). Functions Sonolus does not provide a call stack so user defined functions in Trebla do not use a call stack either. While it would be technically possible to implement one, it would be inefficient and unnecessary to do so. As such, all functions in Trebla are inlined. This restricts the ability to have recursive functions (unless tail call optimized), but in practice it is rarely an issue for intended uses. It also makes it possible to emulate some features usually only found in dynamic languages such as function parameters without specified types, and provide a larger variety of first-class values such as direct references to types themselves.","title":"Project Background"},{"location":"about/project-background/#project-background","text":"Trebla is a programming language targeting the script format used by levels in Sonolus, a rhythm game (a game where the player generally completes actions according to the beat of background music) where all behavior in a level is governed by user defined scripts. For more information about Sonolus, check out the website or the wiki for more information.","title":"Project Background"},{"location":"about/project-background/#sonolus","text":"Many design aspects of Trebla are best understood in the context of the execution model used by Sonolus.","title":"Sonolus"},{"location":"about/project-background/#nodes","text":"A level in Sonolus is simply a JSON file defining gameplay elements and their behaviors. The behavior of a level is defined in its script which is a single array of \"nodes\". A node can be either: (1) a builtin function which references other nodes by index as arguments, including special control flow functions (If, While, ...), mathematical functions (Add, Subtract, ...), memory related functions (Get, Set, ...), and gameplay related functions(Draw, Play, ...), or (2) a literal floating-point value. Gameplay elements (entities) can reference particular nodes as callbacks to be called at different times, such as every frame or in response to player input. Directly editing nodes by hand would be tedious, so scripting is generally done in another language which compiles down to nodes. The provided SIL language is one such language, providing a basic interface on top of nodes. Trebla aims to provide a higher level language and a more familiar programming experience than SIL.","title":"Nodes"},{"location":"about/project-background/#memory","text":"Scripts can store or read data from a number of blocks , arrays of numbers defined for various purposes. Blocks can either have a fixed size or vary in size based on the number of entities defined in a level. Some blocks are specific to the entity calling a script while others are shared globally. Some languages for Sonolus such as the provided SIL language require users to manually specify and manage memory indexes. Trebla abstracts this away, automatically assigning memory to user defined variables. This includes both statically assigning memory locations (blocks indexes) for global or entity related variables, and potentially assigning multiple memory locations and reusing memory locations for temporary variables to minimize memory used (this essentially uses the same algorithms as register allocation where each memory location can be thought of as a register).","title":"Memory"},{"location":"about/project-background/#functions","text":"Sonolus does not provide a call stack so user defined functions in Trebla do not use a call stack either. While it would be technically possible to implement one, it would be inefficient and unnecessary to do so. As such, all functions in Trebla are inlined. This restricts the ability to have recursive functions (unless tail call optimized), but in practice it is rarely an issue for intended uses. It also makes it possible to emulate some features usually only found in dynamic languages such as function parameters without specified types, and provide a larger variety of first-class values such as direct references to types themselves.","title":"Functions"},{"location":"guides/server-setup/","text":"Server Setup To create an engine and levels on Sonolus, a server must first be created to host level files. This guide will detail how to set up a local web server which will host created levels. Setting up a local server Windows IIS Setup This step describes how to set up Internet Information Services (IIS), which comes included in Windows installations, though generally not enabled by default. Note that administrator privileges will needed for this step and the next. Open Control Panel. Under \"Programs\", select \"Turn Windows features on or off\". A prompt should appear. Find \"Internet Information Services\" and check the checkbox. Click OK to dismiss the prompt and allow features to install. Reboot if prompted. In a browser navigate to http://localhost and ensure that a webpage opens. Sonolus Server Setup IIS creates a directory C:\\inetpub\\wwwroot by default, where hosted files are stored. To start, the Sonolus server files may be downloaded from https://github.com/NonSpicyBurrito/sonolus-wiki/releases. Download server.zip under assets from the latest version. Create a subdirectory under C:\\inetpub\\wwwroot and name it sonolus. Extract the contents of server.zip into the directory created in step 3. Open the command prompt, either by searching cmd in the start menu or opening the run menu with Win + R and typing in cmd . Type in ipconfig and hit enter. Find the IPv4 address under Ethernet or Wireless LAN depending on which type of connection is in use and keep note of it. Open Sonolus on a mobile device and ensure that it is connected to the same network as the server. Add a server with address http://[IP from step 6]/sonolus and connect to it. Ensure both example levels are playable.","title":"Server Setup"},{"location":"guides/server-setup/#server-setup","text":"To create an engine and levels on Sonolus, a server must first be created to host level files. This guide will detail how to set up a local web server which will host created levels.","title":"Server Setup"},{"location":"guides/server-setup/#setting-up-a-local-server","text":"","title":"Setting up a local server"},{"location":"guides/server-setup/#windows","text":"","title":"Windows"},{"location":"guides/server-setup/#iis-setup","text":"This step describes how to set up Internet Information Services (IIS), which comes included in Windows installations, though generally not enabled by default. Note that administrator privileges will needed for this step and the next. Open Control Panel. Under \"Programs\", select \"Turn Windows features on or off\". A prompt should appear. Find \"Internet Information Services\" and check the checkbox. Click OK to dismiss the prompt and allow features to install. Reboot if prompted. In a browser navigate to http://localhost and ensure that a webpage opens.","title":"IIS Setup"},{"location":"guides/server-setup/#sonolus-server-setup","text":"IIS creates a directory C:\\inetpub\\wwwroot by default, where hosted files are stored. To start, the Sonolus server files may be downloaded from https://github.com/NonSpicyBurrito/sonolus-wiki/releases. Download server.zip under assets from the latest version. Create a subdirectory under C:\\inetpub\\wwwroot and name it sonolus. Extract the contents of server.zip into the directory created in step 3. Open the command prompt, either by searching cmd in the start menu or opening the run menu with Win + R and typing in cmd . Type in ipconfig and hit enter. Find the IPv4 address under Ethernet or Wireless LAN depending on which type of connection is in use and keep note of it. Open Sonolus on a mobile device and ensure that it is connected to the same network as the server. Add a server with address http://[IP from step 6]/sonolus and connect to it. Ensure both example levels are playable.","title":"Sonolus Server Setup"},{"location":"resources/quick-reference/","text":"Quick Reference This reference details the main features of Trebla and assumes some existing programming experience as well of knowledge of the Sonolus docs . Note that this is a new language, and features may be added, removed, or changed frequently. Bugs may be reported at https://github.com/qwewqa/trebla/issues . Setup Go to https://github.com/qwewqa/trebla/releases and download an image file for the respective operating system. Extract the archive and add the bin directory to the PATH if desired. Project Setup Commands Initializing an empty project in the provided folder. $ trebla init [ PATH ] Building the engine in the provided project folder. $ trebla build [ PATH ] Building levels in the provided project folder. $ trebla levels [ PATH ] Building the engine and levels in the provided project folder. $ trebla compileAll [ PATH ] Project structure Within a project directory there is a treblaproj.yaml file. This specifies the level, source, and output directories, as well as buckets and options as defined by Sonolus. The source directory includes Trebla files, with the .trb extension. The contents of these files are detailed in the following sections. The level directory includes Level files with the .tlv extension. These files are formatted as follows. // Specifies an entity with provided archetype and data values. Archetype(argName1 = value1, argName2 = value2, ...) // Specifies an entity with provided archetype and data values. // Additionally, `name` may be used to refer to the index of this entity. name = Archetype(argName1 = value1, argName2 = value2, ...) // Overrides the previous value of `name` name = Archetype(argName1 = value1, argName2 = value2, ...) General Concepts Scope Declarations in Trebla all belong in some scope. This might be the package, at the top level, or within a script or function. They are accessible from the scope that they are contained in, or within scopes that are children of that scope. No two declarations can share the same name (identifier) in the same scope. Different declarations may have the same name if they have different signatures. Three types of signatures exist. - The default signature that most declarations have. - The receiver signature that functions with receivers (methods) have - The archetype receiver, only used by archetypes. Importing a package brings all the declarations in that package into the scope of the importing file. This does not impact other files declared with the same package nor the contents of the package when imported by another file. Values Anything that is interacted with in code has a value. This includes functions, struct declarations, literals, variables, scripts, and more. Comments Comments start with // and last until the end of a line, or are wrapped in a starting /* and a closing */ . // Line comment struct Foo(x: Number) // End of line comment. /* Block Comments Something End of Comment */ func bar() { /* Another Comment */ } Variables Variables, also known as properties, are declared using the var keyword. Regardless of the type of variable, a variable will always take up actual memory in the relevant block . Note There are cases where an unnecessary allocation may be optimized out, but this case happens transparently and only for temporary variables. Normal Variables Normal variables are declared directly within scripts without any additional modifiers, where they will be members of the script and will be accessible from callbacks within the script. They may also be declared as temporary variables within functions, where they are limited to the local scope. Temporary variables require an initializer expression and optionally take a type. Script member variables optionally have an initializer expression and optionally take a type. script Script { var a = 1 var b: Boolean = true } func Run { var a = 1 var b: Boolean = true } Top level variables Top level variables are declared with the level or temp modifiers. They exist in the corresponding blocks in Sonolus, and may be accessed from different scripts. Top level variables do not take an initializer and are required to have a type. level Located in level memory. Accessible from all callbacks and writable in updateSequential and touch . Does not take an initializer and requires a type. temp Located in temporary memory. Accessible only from the touch callback. Does not take an initializer and requires a type. level var a: Number temp var b: Boolean Script member variables variables In addition to the normal variable, script member variables may be declared with the spawn , data , or shared modifiers. Like top level variables, they require a type and do not take an initializer. spawn Located in entity memory. May be initialized if spawned by another entity. Does not take an initializer and requires a type. data Located in entity data. Accessible from all callbacks, but not writable from any. Initialized via entities in a level and archetypes. Does not take an initializer and requires a raw type (Boolean or Number). shared Located in entity shared memory. Accessible from all callbacks and writable in updateSequential and touch . Does not take an initializer and requires a type. script Script { spawn var a: Number data var b: Boolean shared var c: Point } Let declarations Let declarations bind their name to the resulting value from the expression to the right. Like normal variables, they may optionally take a type. Let declarations never take up any memory themselves, but their expression may itself include the use of temporary variables. Let declarations can be located in most places including the top level, scripts, functions, and callbacks. let a = 1 let b: Number = a Differences between let and var The following examples detail some of the differences between let and var. Assume that the examples takes place in the body of a function or callback. // a copies the value of 1. var a = 1 // b has a value of 1. let b = 1 // changes the value of varA to 2. a = 2 // ERROR: b has a value of 1, an integer literal, which is immutable. b = 2 // a copies the value of 1. var a = 1 // b has the value of a. let b = a // c copies the value of a. var c = a // a and b both evaluate to 2. c still evaluates to 1. a = 2 // a and b both evaluate to 3. c still evaluates to 1. b = 3 // a and b both still evaluate to 3. c now evaluates to 4. c = 4 Control Flow If statement Trebla has if-else statements for control flow. if (condition) { // true branch } else { // false branch } if (condition) { // true branch } While statement while (condition) { /* do something */ } For statement for (var i = 0; i < 3; i++) { Clip(i).play() } Function declarations Functions are declared with the func keyword. They may include calls to other functions, but calls to themselves, directly or within another function, are not supported. Functions can be declared in most places including the top level, scripts, other functions, and callbacks. // A function that takes two Number parameters and returns a Number. func sum(a: Number, b: Number): Number { a + b } // A function with an impicit Any return type and an expression body. func sum2(a: Number, b: Number) = a + b // A function which has two parameters of any type and returns any type. func sum3(a, b): Any { b } // A function that returns no meaningful value. fun run(): Unit { Clip(0).play() } // A function that returns no meaninful value with an omitted Unit return type. fun run2() { Clip(0).play() } // A call to the sum function. sum(1, 2) // A call to the sum function with named parameters. sum(b = 2, a = 1) A function may also have default parameters. func sum(a = 0, b = 1) = a + b sum() == sum(0, 1) // true sum(b = 3) == sum(0, 3) // true Receiver Functions Receiver functions, also known as methods, are a special type of function. // Declares a function named translate with // a receiver type of Point named this, as well as two normal number parameters. func (this: Point).translate(x: Number, y: Number) { this.x += x this.y += y } func run() { var p = Point(1, 2) // Calls the method using the dot operator on a struct value. p.translate(5, 6) // Refernces the raw function using the dot on a struct declaration. let translatePoint = Point.translate // Calls the method like a normal function translatePoint(p, 1, 5) } The name of the receiver parameter may also be omitted, and will default to this func Point.translate(x: Number, y: Number) { this.x += x this.y += y } Multiple functions may have the same name if their receiver type is different. Only struct receivers are allowed. Function modifiers The infix modifier allows functions to be called as infix functions. infix func Boolean.and(other: Boolean) = Boolean(builtins.And(this, other)) func run() { var x = true and false // false } The operator modifier allows certain named functions to be used as modifiers. operator func Number.plus(other: Number) = Number(builtins.Add(this, other)) func run() { var x = 1 + 2 } Lambda expressions Lambda expressions are unnamed functions. They are declared with curly braces. Lambdas return the value of their final expression. // By default there's an Any type parameter named it that defaults to Unit. let lambda = { it + 1 } var a = lambda(4) // 5 // Parameters may be specified in parentheses and followed by an arrow. let lambda2 = { (a, b: Number, c = 5) -> a + b + c } var b = lambda2(5, 2) // 12 Lambdas as function parameters Lambdas may be moved out of the parentheses of a function call if they are the final parameter. func foo(a: Function = { 1 }, b: Function = { 2 }) = a() + b() var w = foo({ 5 }, { 6 }) // 11 var x = foo({ 5 }) { 6 } // 11 var y = foo { 6 } // 7; Uses default for parameter a var z = foo({ 6 }) // 8; Uses default for parameter b Boolean Operators The boolean || (or) and && (and) operators are not overloadable. These are special operators, which short circuit. Instead of overriding these operators, the reccomendation is to use infix functions named or and and . func play() { Clip(0).play() } func run() { // Play is never called in either of these cases. false && play() true || play() } Prefix operator function + unaryPlus - unaryMinus ! not ++ preIncrement -- preDecrement Postfix operator function ++ postIncrement -- postDecrement Infix operator function + plus - minus * times / div % mod ** pow += plusAssign -= minusAssign *= timesAssign /= divAssign %= modAssign **= powAssign == equals != notEquals > greater < less >= greaterOr <= lessOr Struct declarations Structs are collections of values. Struct declarations can be used as types, and they can be called like functions. // Declares a struct named Point, which contains two fields (values), // which are named x and y struct Point(x: Number, y: Number) func run() { // Binds Point(1, 2) as the value of p1 let p1 = Point(1, 2) // Copies the value of the point as p2 var p2 = Point(x = 1, y = 5) // Changes the value of x in p2 p2.x = 5 } Structs usually contain other structs, but may sometimes contain other values. This will limit where they can be used however. struct Foo(num: Number, fun: Function) func bar1() { /* does nothing and returns Unit */ } func bar2() { } func run() { var x = Foo(1, bar1) // Allowed. Numbers in variables are mutable. x.num = 2 // Allowed, but does nothing. Functions are the same. x.fun = bar1 // ERROR: Functions are not mutable. x.fun = bar2 // Allowed. x = Foo(2, bar1) // ERROR: Functions are not mutable. x = Foo(2, bar2) } // ERROR: Function is not allocatable. level var x: Foo Raw Structs Raw structs have the raw modifier. They have no declared fields, and are backed by either a literal value, a call to a builtin Sonolus function, or a location in memory. There are three raw structs in the standard library, and it generally is unnecessary to declare more. A struct is allocatable if it only has fields that are typed as raw structs or other allocatable structs. Variables that don't take an initializer must be annotated with an allocatable struct type. // Default for integer and float literals. raw struct Number // Default for boolean literals. raw struct Boolean // Default in other cases raw struct Raw Script declarations Scripts are declared with the script keyword. script Note { /* Script Members */ } Callbacks Scripts contain callbacks, which correspond to callbacks in Sonolus. script Note { callback updateParallel { /* Callback body */ } } The initialize callback in Sonolus is not declared explicitly. Instead, it is described inline with init blocks. script Note { data var large: Boolean var width: Number init { if (large) { width = 0.8 } else { width = 0.4 } } var height = width / 2 } Packages Files in Trebla are organized into packages. They are declared with the package statement at the top of a file. // Declares that this file is in package c, contained within package b // which is contained within the top level package a. package a.b.c If no package is specified the default is one named engine . Visibility Modifiers There are three visibility modifiers in Trebla: public , internal , and private . public declarations can be imported, and are accessible by all files in the same package by default including subpackages. internal declarations cannot be imported, but are still accessible by all files in the same package including subpackages. private declarations cannot be imported, and can only be accessed in the particular file the declares it. Visibility modifiers outside of the top level currently do not do anything. Importing The public contents of a package may be imported with an import statement. They come below the package declaration (if any) and before the rest of the file. // A wildcard import imports everything in a package. import name.of.package.* // Or, a specific declaration can be imported. import name.of.package.Declaration","title":"Quick Reference"},{"location":"resources/quick-reference/#quick-reference","text":"This reference details the main features of Trebla and assumes some existing programming experience as well of knowledge of the Sonolus docs . Note that this is a new language, and features may be added, removed, or changed frequently. Bugs may be reported at https://github.com/qwewqa/trebla/issues .","title":"Quick Reference"},{"location":"resources/quick-reference/#setup","text":"Go to https://github.com/qwewqa/trebla/releases and download an image file for the respective operating system. Extract the archive and add the bin directory to the PATH if desired.","title":"Setup"},{"location":"resources/quick-reference/#project-setup","text":"","title":"Project Setup"},{"location":"resources/quick-reference/#commands","text":"Initializing an empty project in the provided folder. $ trebla init [ PATH ] Building the engine in the provided project folder. $ trebla build [ PATH ] Building levels in the provided project folder. $ trebla levels [ PATH ] Building the engine and levels in the provided project folder. $ trebla compileAll [ PATH ]","title":"Commands"},{"location":"resources/quick-reference/#project-structure","text":"Within a project directory there is a treblaproj.yaml file. This specifies the level, source, and output directories, as well as buckets and options as defined by Sonolus. The source directory includes Trebla files, with the .trb extension. The contents of these files are detailed in the following sections. The level directory includes Level files with the .tlv extension. These files are formatted as follows. // Specifies an entity with provided archetype and data values. Archetype(argName1 = value1, argName2 = value2, ...) // Specifies an entity with provided archetype and data values. // Additionally, `name` may be used to refer to the index of this entity. name = Archetype(argName1 = value1, argName2 = value2, ...) // Overrides the previous value of `name` name = Archetype(argName1 = value1, argName2 = value2, ...)","title":"Project structure"},{"location":"resources/quick-reference/#general-concepts","text":"","title":"General Concepts"},{"location":"resources/quick-reference/#scope","text":"Declarations in Trebla all belong in some scope. This might be the package, at the top level, or within a script or function. They are accessible from the scope that they are contained in, or within scopes that are children of that scope. No two declarations can share the same name (identifier) in the same scope. Different declarations may have the same name if they have different signatures. Three types of signatures exist. - The default signature that most declarations have. - The receiver signature that functions with receivers (methods) have - The archetype receiver, only used by archetypes. Importing a package brings all the declarations in that package into the scope of the importing file. This does not impact other files declared with the same package nor the contents of the package when imported by another file.","title":"Scope"},{"location":"resources/quick-reference/#values","text":"Anything that is interacted with in code has a value. This includes functions, struct declarations, literals, variables, scripts, and more.","title":"Values"},{"location":"resources/quick-reference/#comments","text":"Comments start with // and last until the end of a line, or are wrapped in a starting /* and a closing */ . // Line comment struct Foo(x: Number) // End of line comment. /* Block Comments Something End of Comment */ func bar() { /* Another Comment */ }","title":"Comments"},{"location":"resources/quick-reference/#variables","text":"Variables, also known as properties, are declared using the var keyword. Regardless of the type of variable, a variable will always take up actual memory in the relevant block . Note There are cases where an unnecessary allocation may be optimized out, but this case happens transparently and only for temporary variables.","title":"Variables"},{"location":"resources/quick-reference/#normal-variables","text":"Normal variables are declared directly within scripts without any additional modifiers, where they will be members of the script and will be accessible from callbacks within the script. They may also be declared as temporary variables within functions, where they are limited to the local scope. Temporary variables require an initializer expression and optionally take a type. Script member variables optionally have an initializer expression and optionally take a type. script Script { var a = 1 var b: Boolean = true } func Run { var a = 1 var b: Boolean = true }","title":"Normal Variables"},{"location":"resources/quick-reference/#top-level-variables","text":"Top level variables are declared with the level or temp modifiers. They exist in the corresponding blocks in Sonolus, and may be accessed from different scripts. Top level variables do not take an initializer and are required to have a type. level Located in level memory. Accessible from all callbacks and writable in updateSequential and touch . Does not take an initializer and requires a type. temp Located in temporary memory. Accessible only from the touch callback. Does not take an initializer and requires a type. level var a: Number temp var b: Boolean","title":"Top level variables"},{"location":"resources/quick-reference/#script-member-variables-variables","text":"In addition to the normal variable, script member variables may be declared with the spawn , data , or shared modifiers. Like top level variables, they require a type and do not take an initializer. spawn Located in entity memory. May be initialized if spawned by another entity. Does not take an initializer and requires a type. data Located in entity data. Accessible from all callbacks, but not writable from any. Initialized via entities in a level and archetypes. Does not take an initializer and requires a raw type (Boolean or Number). shared Located in entity shared memory. Accessible from all callbacks and writable in updateSequential and touch . Does not take an initializer and requires a type. script Script { spawn var a: Number data var b: Boolean shared var c: Point }","title":"Script member variables variables"},{"location":"resources/quick-reference/#let-declarations","text":"Let declarations bind their name to the resulting value from the expression to the right. Like normal variables, they may optionally take a type. Let declarations never take up any memory themselves, but their expression may itself include the use of temporary variables. Let declarations can be located in most places including the top level, scripts, functions, and callbacks. let a = 1 let b: Number = a","title":"Let declarations"},{"location":"resources/quick-reference/#differences-between-let-and-var","text":"The following examples detail some of the differences between let and var. Assume that the examples takes place in the body of a function or callback. // a copies the value of 1. var a = 1 // b has a value of 1. let b = 1 // changes the value of varA to 2. a = 2 // ERROR: b has a value of 1, an integer literal, which is immutable. b = 2 // a copies the value of 1. var a = 1 // b has the value of a. let b = a // c copies the value of a. var c = a // a and b both evaluate to 2. c still evaluates to 1. a = 2 // a and b both evaluate to 3. c still evaluates to 1. b = 3 // a and b both still evaluate to 3. c now evaluates to 4. c = 4","title":"Differences between let and var"},{"location":"resources/quick-reference/#control-flow","text":"","title":"Control Flow"},{"location":"resources/quick-reference/#if-statement","text":"Trebla has if-else statements for control flow. if (condition) { // true branch } else { // false branch } if (condition) { // true branch }","title":"If statement"},{"location":"resources/quick-reference/#while-statement","text":"while (condition) { /* do something */ }","title":"While statement"},{"location":"resources/quick-reference/#for-statement","text":"for (var i = 0; i < 3; i++) { Clip(i).play() }","title":"For statement"},{"location":"resources/quick-reference/#function-declarations","text":"Functions are declared with the func keyword. They may include calls to other functions, but calls to themselves, directly or within another function, are not supported. Functions can be declared in most places including the top level, scripts, other functions, and callbacks. // A function that takes two Number parameters and returns a Number. func sum(a: Number, b: Number): Number { a + b } // A function with an impicit Any return type and an expression body. func sum2(a: Number, b: Number) = a + b // A function which has two parameters of any type and returns any type. func sum3(a, b): Any { b } // A function that returns no meaningful value. fun run(): Unit { Clip(0).play() } // A function that returns no meaninful value with an omitted Unit return type. fun run2() { Clip(0).play() } // A call to the sum function. sum(1, 2) // A call to the sum function with named parameters. sum(b = 2, a = 1) A function may also have default parameters. func sum(a = 0, b = 1) = a + b sum() == sum(0, 1) // true sum(b = 3) == sum(0, 3) // true","title":"Function declarations"},{"location":"resources/quick-reference/#receiver-functions","text":"Receiver functions, also known as methods, are a special type of function. // Declares a function named translate with // a receiver type of Point named this, as well as two normal number parameters. func (this: Point).translate(x: Number, y: Number) { this.x += x this.y += y } func run() { var p = Point(1, 2) // Calls the method using the dot operator on a struct value. p.translate(5, 6) // Refernces the raw function using the dot on a struct declaration. let translatePoint = Point.translate // Calls the method like a normal function translatePoint(p, 1, 5) } The name of the receiver parameter may also be omitted, and will default to this func Point.translate(x: Number, y: Number) { this.x += x this.y += y } Multiple functions may have the same name if their receiver type is different. Only struct receivers are allowed.","title":"Receiver Functions"},{"location":"resources/quick-reference/#function-modifiers","text":"The infix modifier allows functions to be called as infix functions. infix func Boolean.and(other: Boolean) = Boolean(builtins.And(this, other)) func run() { var x = true and false // false } The operator modifier allows certain named functions to be used as modifiers. operator func Number.plus(other: Number) = Number(builtins.Add(this, other)) func run() { var x = 1 + 2 }","title":"Function modifiers"},{"location":"resources/quick-reference/#lambda-expressions","text":"Lambda expressions are unnamed functions. They are declared with curly braces. Lambdas return the value of their final expression. // By default there's an Any type parameter named it that defaults to Unit. let lambda = { it + 1 } var a = lambda(4) // 5 // Parameters may be specified in parentheses and followed by an arrow. let lambda2 = { (a, b: Number, c = 5) -> a + b + c } var b = lambda2(5, 2) // 12","title":"Lambda expressions"},{"location":"resources/quick-reference/#lambdas-as-function-parameters","text":"Lambdas may be moved out of the parentheses of a function call if they are the final parameter. func foo(a: Function = { 1 }, b: Function = { 2 }) = a() + b() var w = foo({ 5 }, { 6 }) // 11 var x = foo({ 5 }) { 6 } // 11 var y = foo { 6 } // 7; Uses default for parameter a var z = foo({ 6 }) // 8; Uses default for parameter b","title":"Lambdas as function parameters"},{"location":"resources/quick-reference/#boolean-operators","text":"The boolean || (or) and && (and) operators are not overloadable. These are special operators, which short circuit. Instead of overriding these operators, the reccomendation is to use infix functions named or and and . func play() { Clip(0).play() } func run() { // Play is never called in either of these cases. false && play() true || play() } Prefix operator function + unaryPlus - unaryMinus ! not ++ preIncrement -- preDecrement Postfix operator function ++ postIncrement -- postDecrement Infix operator function + plus - minus * times / div % mod ** pow += plusAssign -= minusAssign *= timesAssign /= divAssign %= modAssign **= powAssign == equals != notEquals > greater < less >= greaterOr <= lessOr","title":"Boolean Operators"},{"location":"resources/quick-reference/#struct-declarations","text":"Structs are collections of values. Struct declarations can be used as types, and they can be called like functions. // Declares a struct named Point, which contains two fields (values), // which are named x and y struct Point(x: Number, y: Number) func run() { // Binds Point(1, 2) as the value of p1 let p1 = Point(1, 2) // Copies the value of the point as p2 var p2 = Point(x = 1, y = 5) // Changes the value of x in p2 p2.x = 5 } Structs usually contain other structs, but may sometimes contain other values. This will limit where they can be used however. struct Foo(num: Number, fun: Function) func bar1() { /* does nothing and returns Unit */ } func bar2() { } func run() { var x = Foo(1, bar1) // Allowed. Numbers in variables are mutable. x.num = 2 // Allowed, but does nothing. Functions are the same. x.fun = bar1 // ERROR: Functions are not mutable. x.fun = bar2 // Allowed. x = Foo(2, bar1) // ERROR: Functions are not mutable. x = Foo(2, bar2) } // ERROR: Function is not allocatable. level var x: Foo","title":"Struct declarations"},{"location":"resources/quick-reference/#raw-structs","text":"Raw structs have the raw modifier. They have no declared fields, and are backed by either a literal value, a call to a builtin Sonolus function, or a location in memory. There are three raw structs in the standard library, and it generally is unnecessary to declare more. A struct is allocatable if it only has fields that are typed as raw structs or other allocatable structs. Variables that don't take an initializer must be annotated with an allocatable struct type. // Default for integer and float literals. raw struct Number // Default for boolean literals. raw struct Boolean // Default in other cases raw struct Raw","title":"Raw Structs"},{"location":"resources/quick-reference/#script-declarations","text":"Scripts are declared with the script keyword. script Note { /* Script Members */ }","title":"Script declarations"},{"location":"resources/quick-reference/#callbacks","text":"Scripts contain callbacks, which correspond to callbacks in Sonolus. script Note { callback updateParallel { /* Callback body */ } } The initialize callback in Sonolus is not declared explicitly. Instead, it is described inline with init blocks. script Note { data var large: Boolean var width: Number init { if (large) { width = 0.8 } else { width = 0.4 } } var height = width / 2 }","title":"Callbacks"},{"location":"resources/quick-reference/#packages","text":"Files in Trebla are organized into packages. They are declared with the package statement at the top of a file. // Declares that this file is in package c, contained within package b // which is contained within the top level package a. package a.b.c If no package is specified the default is one named engine .","title":"Packages"},{"location":"resources/quick-reference/#visibility-modifiers","text":"There are three visibility modifiers in Trebla: public , internal , and private . public declarations can be imported, and are accessible by all files in the same package by default including subpackages. internal declarations cannot be imported, but are still accessible by all files in the same package including subpackages. private declarations cannot be imported, and can only be accessed in the particular file the declares it. Visibility modifiers outside of the top level currently do not do anything.","title":"Visibility Modifiers"},{"location":"resources/quick-reference/#importing","text":"The public contents of a package may be imported with an import statement. They come below the package declaration (if any) and before the rest of the file. // A wildcard import imports everything in a package. import name.of.package.* // Or, a specific declaration can be imported. import name.of.package.Declaration","title":"Importing"}]}